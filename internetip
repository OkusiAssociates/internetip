#!/usr/bin/env bash
# Fetch and validate public internet IP address

# Source valid_ip function if not already available
if ! declare -F valid_ip &>/dev/null; then
  #shellcheck disable=SC1091 source=validip
  source "${BASH_SOURCE[0]%/*}/validip" 2>/dev/null || {
    # Inline fallback if validip not found
    valid_ip() {
      local -- ip="${1:-}"
      [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]] || return 1
      local -- IFS='.'
      local -ai octets
      #shellcheck disable=SC2206
      octets=( $ip )
      [[ ${octets[0]} -le 255 && ${octets[1]} -le 255 \
          && ${octets[2]} -le 255 && ${octets[3]} -le 255 ]]
    }
  }
fi

get_internet_ip() {
  local -- ip
  ip=$(curl -sf --max-time 10 'http://ipecho.net/plain' 2>/dev/null | head -n1)
  valid_ip "$ip" || return 1
  echo "$ip"
}
internetip() { get_internet_ip "$@"; }
declare -fx get_internet_ip internetip


# Check if the script is being sourced or executed directly
[[ "${BASH_SOURCE[0]}" == "${0}" ]] || return 0
#!/bin/bash #semantic ----------------------------------------------------------
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

VERSION='2.1.0'
SCRIPT_PATH="$(realpath -e -- "$0")"
SCRIPT_DIR="${SCRIPT_PATH%/*}"
SCRIPT_NAME="${SCRIPT_PATH##*/}"
GATEWAY_IP_FILE=/tmp/GatewayIP
#shellcheck disable=SC2034
readonly -- VERSION SCRIPT_PATH SCRIPT_DIR SCRIPT_NAME GATEWAY_IP_FILE

# Configurable callback URL (can be overridden via environment)
: "${INTERNETIP_CALL_URL:=https://okusiassociates.com/ip.php?1=**Farkle420**&2=$HOSTNAME}"

# Color support for stderr
#shellcheck disable=SC2015,SC2034
if [[ -t 2 ]]; then
  declare -r RED=$'\033[0;31m' NOCOLOR=$'\033[0m'
else
  declare -r RED='' NOCOLOR=''
fi

error() {
  local -- msg
  for msg in "$@"; do
    >&2 printf '%s: %serror%s: %s\n' "$SCRIPT_NAME" "$RED" "$NOCOLOR" "$msg"
  done
}

die() {
  local -i exitcode=1
  (($#)) && { exitcode=$1; shift; }
  (($#)) && error "$@"
  exit "$exitcode"
}

show_help() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Fetch and display public internet IP address

Usage: $SCRIPT_NAME [options]
       source $SCRIPT_NAME  # Load get_internet_ip function

Options:
  -s            Call callback URL after fetching IP
  --install     Install scripts to /usr/local/bin (requires root)
  --update      Git pull and reinstall (requires root)
  --uninstall   Remove scripts from /usr/local/bin (requires root)
  -h, --help    Display this help
  -V, --version Display version

Environment:
  INTERNETIP_CALL_URL  Callback URL for -s option (default: okusiassociates.com)

Exported Functions (when sourced):
  get_internet_ip   Fetch and validate public IP, returns via stdout
  valid_ip <ip>     Validate IPv4 address format

Notes:
  - Uses ipecho.net to detect public IP
  - Caches result to $GATEWAY_IP_FILE when run as root
  - Uses curl with 10-second timeout

Examples:
  $SCRIPT_NAME                       # Display current public IP
  $SCRIPT_NAME -s                    # Fetch IP and call callback URL

  sudo $SCRIPT_NAME --install        # Install to /usr/local/bin
  sudo $SCRIPT_NAME --update         # Update from git + reinstall
  sudo $SCRIPT_NAME --uninstall      # Remove from /usr/local/bin

  source $SCRIPT_NAME
  ip=\$(get_internet_ip)             # Use in scripts
  valid_ip "\$ip" && echo "Valid"
EOT
}

internetip_call_url() {
  >&2 echo "Calling ${INTERNETIP_CALL_URL@Q}"
  curl -sfk --max-time 10 "$INTERNETIP_CALL_URL" >/dev/null \
    || die 1 "Error calling ${INTERNETIP_CALL_URL@Q}"
}

do_install() {
  ((EUID == 0)) || die 1 "Install requires root. Try: sudo $SCRIPT_NAME --install"

  local -a scripts=(internetip validip watchip)
  local -- script

  for script in "${scripts[@]}"; do
    [[ -x $SCRIPT_DIR/$script ]] || die 1 "Script not found: $SCRIPT_DIR/$script"
    ln -sf "$SCRIPT_DIR/$script" "/usr/local/bin/$script"
    echo "Installed: /usr/local/bin/$script -> $SCRIPT_DIR/$script"
  done

  # Bash completion
  if [[ -d /etc/bash_completion.d && -f $SCRIPT_DIR/internetip.bash_completion ]]; then
    ln -sf "$SCRIPT_DIR/internetip.bash_completion" "/etc/bash_completion.d/internetip"
    echo "Installed: /etc/bash_completion.d/internetip"
  fi

  echo "Installation complete"
}

do_update() {
  ((EUID == 0)) || die 1 "Update requires root. Try: sudo $SCRIPT_NAME --update"

  cd "$SCRIPT_DIR" || die 1 "Cannot cd to $SCRIPT_DIR"

  if [[ ! -d .git ]]; then
    die 1 "Not a git repository: $SCRIPT_DIR"
  fi

  git pull || die 1 "Git pull failed"
  echo "Updated from git"

  # Reinstall if already installed
  if [[ -L /usr/local/bin/internetip ]]; then
    do_install
  fi
}

do_uninstall() {
  ((EUID == 0)) || die 1 "Uninstall requires root. Try: sudo $SCRIPT_NAME --uninstall"

  rm -f /usr/local/bin/{internetip,validip,watchip}
  rm -f /etc/bash_completion.d/internetip

  echo "Uninstalled internetip, validip, watchip from /usr/local/bin"
}

main() {
  local -- gatewayip

  # Parse options
  while (($#)); do
    case $1 in
      -h|--help)    show_help; return 0 ;;
      -V|--version) echo "$SCRIPT_NAME $VERSION"; return 0 ;;
      -s)           internetip_call_url ;;
      --install)    do_install; return 0 ;;
      --update)     do_update; return 0 ;;
      --uninstall)  do_uninstall; return 0 ;;
      -*)           die 22 "Unknown option ${1@Q}. Try: $SCRIPT_NAME --help" ;;
      *)            die 22 "Unexpected argument ${1@Q}" ;;
    esac
    shift
  done

  # Fetch and validate IP
  gatewayip=$(get_internet_ip) || die 1 'Failed to retrieve valid IP'

  # Cache to file if root
  if ((EUID == 0)); then
    echo "$gatewayip" > "$GATEWAY_IP_FILE"
    chmod 664 "$GATEWAY_IP_FILE"
  fi

  echo "$gatewayip"
}

main "$@"
#fin
