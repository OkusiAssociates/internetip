#!/usr/bin/env bash
# Monitor and log public IP address changes

# Source get_internet_ip function if not already available
if ! declare -F get_internet_ip &>/dev/null; then
  #shellcheck disable=SC1091 source=internetip
  source "${BASH_SOURCE[0]%/*}"/internetip 2>/dev/null || {
    source internetip 2>/dev/null || {
      >&2 echo 'watchip: error: Cannot source internetip module'
      #shellcheck disable=SC2317
      return 1 2>/dev/null || exit 1
    }
  }
fi

watch_ip() {
  local -- ipfile="${1:-/tmp/internetip.txt}"
  local -- oldip curip

  # First run: fetch once, store, return
  if [[ ! -f $ipfile ]]; then
    curip=$(get_internet_ip) || return 1
    echo "$curip" > "$ipfile"
    echo "initial:$curip"
    return 0
  fi

  # Subsequent runs: read stored, fetch current, compare
  oldip=$(<"$ipfile")
  curip=$(get_internet_ip) || return 1

  if [[ $oldip != "$curip" ]]; then
    echo "$curip" > "$ipfile"
    echo "changed:$oldip:$curip"
  else
    echo "unchanged:$curip"
  fi
}
declare -fx watch_ip

# Check if the script is being sourced or executed directly
[[ "${BASH_SOURCE[0]}" == "${0}" ]] || return 0
#!/bin/bash #semantic ----------------------------------------------------------
set -euo pipefail
shopt -s inherit_errexit extglob nullglob

VERSION=2.1.0
SCRIPT_PATH=$(realpath -e -- "$0")
SCRIPT_NAME=${SCRIPT_PATH##*/}
readonly -- VERSION SCRIPT_NAME SCRIPT_PATH

declare -- IPFILE=${IPFILE:-/tmp/"$SCRIPT_NAME".txt}

# LOGFILE with fallback: /var/log if writable, else ~/
declare -- LOGFILE=${LOGFILE:-}
if [[ -z $LOGFILE ]]; then
  LOGFILE="/var/log/$SCRIPT_NAME.log"
  if ! touch "$LOGFILE" 2>/dev/null; then
    LOGFILE="$HOME/.$SCRIPT_NAME.log"
  fi
fi

log_msg() {
  local -- ts
  ts=$(date '+%Y-%m-%d %H:%M:%S')
  echo "$ts $USER: $*" >> "$LOGFILE" 2>/dev/null || true
}

log_sys() { ((EUID)) || logger -t "$SCRIPT_NAME" -p local0.notice "$@"; log_msg "$@"; echo "$@"; }
log_err() { ((EUID)) || logger -t "$SCRIPT_NAME" -p local0.err "ERROR: $*"; log_msg "ERROR: $*"; >&2 echo "$@"; }
log_die() { log_err "$@"; exit 1; }

do_log() {
  if [[ -f $LOGFILE && -r $LOGFILE ]]; then
    cat "$LOGFILE"
  else
    >&2 echo "$SCRIPT_NAME: Cannot read log: $LOGFILE"
    return 1
  fi
}

show_help() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Monitor and log public IP address changes

Usage: $SCRIPT_NAME [options]
       source $SCRIPT_NAME  # Load watch_ip function

Options:
  -l, --log     Display log file contents
  -q, --quiet   Suppress output when IP unchanged
  -h, --help    Display this help
  -V, --version Display version

Exported Functions (when sourced):
  watch_ip [file]   Compare stored vs current IP
                    Returns: "changed:old:new" or "unchanged:ip"

Behavior:
  - Logs to syslog when run as root (local0.notice)
  - Logs all activity to LOGFILE
  - Calls internetip -s on change to notify remote server
  - Stores current IP in IPFILE

Environment:
  LOGFILE       Log file (default: /var/log/watchip.log,
                falls back to ~/.watchip.log if not writable)
  IPFILE        IP tracking file (default: /tmp/internetip.txt)

Exit Codes:
  0   Success (IP checked)
  1   Error fetching or processing IP
  22  Invalid option (EINVAL)

Examples:
  $SCRIPT_NAME                   # Check for IP change
  $SCRIPT_NAME -q                # Quiet mode (for cron)

  # Cron job (check every 5 minutes)
  */5 * * * * /usr/local/bin/$SCRIPT_NAME -q

  # Sourced mode
  source $SCRIPT_NAME
  result=\$(watch_ip /tmp/myapp_ip.txt)
  [[ \$result == changed:* ]] && echo "IP changed!"
EOT
}

main() {
  local -- quiet=0 result oldip curip

  # Parse options
  while (($#)); do
    case $1 in
      -h|--help)    show_help; return 0 ;;
      -V|--version) echo "$SCRIPT_NAME $VERSION"; return 0 ;;
      -l|--log|log) do_log; return $? ;;
      -q|--quiet)   quiet=1 ;;
      -*)           log_die "Unknown option ${1@Q}. Try: $SCRIPT_NAME --help" ;;
      *)            log_die "Unexpected argument ${1@Q}" ;;
    esac
    shift
  done

  # Watch for changes
  result=$(watch_ip "$IPFILE") || log_die 'Error checking IP'

  if [[ $result == initial:* ]]; then
    # First run: initial:ip
    curip="${result#initial:}"
    log_sys "Initial IP: $curip"
  elif [[ $result == changed:* ]]; then
    # Parse result: changed:oldip:newip
    oldip="${result#changed:}"
    curip="${oldip#*:}"
    oldip="${oldip%%:*}"
    # Store to remote and log
    internetip -s >/dev/null 2>&1 || true
    log_sys "IP changed from $oldip to $curip"
  else
    # unchanged:ip
    curip="${result#unchanged:}"
    ((quiet)) || echo "IP unchanged: $curip"
  fi
}

main "$@"
#fin
